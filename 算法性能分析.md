#什么是时间复杂度
**时间复杂度是一个函数，它定性描述该算法的运行时间。**
假设算法的问题规模为n，那么操作单元数量便用函数f(n)来表示，随着数据规模n的增大，算法执行时间的增长率和f(n)的增长率相同，这称作为算法的渐近时间复杂度，简称时间复杂度，记为 O(f(n))。

#什么是O
算法导论给出的解释：**大O用来表示上界的**，当用它作为算法的最坏情况运行时间的上界，就是对任意数据输入的运行时间的上界。

#不同数据规模的差异
*在决定使用哪些算法的时候，不是时间复杂越低的越好（因为简化后的时间复杂度忽略了常数项等等），要考虑**数据规模**，如果数据规模很小甚至可以用O(n^2)的算法比O(n)的更合适（在有常数项的时候）*

**因为大O就是数据量级突破一个点且数据量级非常大的情况下所表现出的时间复杂度，这个数据量也就是常数项系数已经不起决定性作用的数据量**
![时间复杂度](https://code-thinking-1253855093.file.myqcloud.com/pics/20200728191447384-20230310124015324.png)

**O(1)常数阶 < O(logn)对数阶 < O(n)线性阶 < O(nlogn)线性对数阶 < O(n^2)平方阶 < O(n^3)立方阶 < O(2^n)指数阶**

**如果常数项非常大，也需要成为一个考虑的因素**

#复杂表达式的化简
```cpp
O(2*n^2 + 10*n + 1000)
```
**去掉运行时间中的加法常数项 （因为常数项并不会因为n的增大而增加计算机的操作次数）**
```cpp
O(2*n^2 + 10*n)
```
去掉常数系数
```cpp
O(n^2 + n)
```
只保留保留最高项，去掉数量级小一级的n （因为n^2 的数据规模远大于n），最终简化为：
```cpp
O(n^2)
```
#O(logn)中的log是以什么为底？
平时说这个算法的时间复杂度是logn的，那么一定是log 以2为底n的对数么？
其实不然，也可以是以10为底n的对数，也可以是以20为底n的对数，但我们统一说 logn，也就是忽略底数的描述。

![不同对数的运算](https://code-thinking-1253855093.file.myqcloud.com/pics/20200728191447349-20230310124032001.png)

#举一个例子
通过这道面试题目，来分析一下时间复杂度。题目描述：找出n个字符串中相同的两个字符串（假设这里只有两个相同的字符串）。

如果是暴力枚举的话，时间复杂度是多少呢，是O(n^2)么？

这里一些同学会忽略了字符串比较的时间消耗，这里并不像int 型数字做比较那么简单，除了n^2 次的遍历次数外，字符串比较依然要消耗m次操作（m也就是字母串的长度），所以时间复杂度是O(m × n × n)。

接下来再想一下其他解题思路。

先排对n个字符串按字典序来排序，排序后n个字符串就是有序的，意味着两个相同的字符串就是挨在一起，然后在遍历一遍n个字符串，这样就找到两个相同的字符串了。

那看看这种算法的时间复杂度，快速排序时间复杂度为O(nlogn)，依然要考虑字符串的长度是m，那么快速排序每次的比较都要有m次的字符比较的操作，就是O(m × n × log n) 。

之后还要遍历一遍这n个字符串找出两个相同的字符串，别忘了遍历的时候依然要比较字符串，所以总共的时间复杂度是 O(m × n × logn + n × m)。

我们对O(m × n × log n + n × m) 进行简化操作，把m × n提取出来变成 O(m × n × (logn + 1))，再省略常数项最后的时间复杂度是 O(m × n × log n)。

最后很明显O(m × n × logn) 要优于O(m × n × n)！

所以先把字符串集合排序再遍历一遍找到两个相同字符串的方法要比直接暴力枚举的方式更快。

这就是我们通过分析两种算法的时间复杂度得来的。

